CurrentNode=which.min(sVec)
#Actions
Actions=AdjacencyMatrix[CurrentNode,]
NodeIndexes=IndicesForNodes(n,IndexForNodeFunction,sVec,vVec,CostVec,LambdaVec,bVec,xVec,vMaxVec)
print(NodeIndexes)
BenefitForAction=Actions * NodeIndexes
#Form Paths
for(action in 1:n)
{
if(Actions[action]==1)
{
Paths=rbind(Paths,c(action,rep(0,NoSteps-1)))
NewsVec=NewSState(sVec,action,BVec)
EvolvedStates=rbind(EvolvedStates,c(NewsVec,NewMeanVState(vVec,NewsVec,action,BVec,bVec,LambdaVec)))
BenefitForPath=c(BenefitForPath,BenefitForAction[action])
}
}
print(paste("I am about to compare all paths of length ",toString(Step)))
print(Paths)
print("They have a benefit of")
print(BenefitForPath)
BestPath=Paths[which.max(BenefitForPath),]
BestPathforStep[Step,]=BestPath
print("I have chosen the path")
print(BestPath)
}
else
{
#We need to copy and expand each
OldPaths=Paths
OldEvolvedStates=EvolvedStates
OldBenefitForPath=BenefitForPath
Paths=matrix(0,nrow=0,ncol=NoSteps)
EvolvedStates=matrix(0,nrow=0,ncol=2*n)
BenefitForPath=vector(length=0)
#We now look at expanding each
for(row in 1:nrow(OldPaths))
{
#for each row we expand it to allow all possible actions
Actions=AdjacencyMatrix[OldPaths[row,Step-1],]
NodeIndexes=IndicesForNodes(n,IndexForNodeFunction,OldEvolvedStates[row,1:n],OldEvolvedStates[row,(n+1):(2*n)],CostVec,LambdaVec,bVec,xVec,vMaxVec)
BenefitForAction=Actions * NodeIndexes
#Form Paths
for(action in 1:n)
{
if(Actions[action]==1)
{
Paths=rbind(Paths,c(OldPaths[row,1:(Step-1)],action,rep(0,NoSteps-Step)))
NewsVec=NewSState(OldEvolvedStates[row,1:n],action,BVec)
EvolvedStates=rbind(EvolvedStates,c(NewsVec,NewMeanVState(OldEvolvedStates[row,(n+1):(2*n)],NewsVec,action,BVec,bVec,LambdaVec)))
BenefitForPath=c(BenefitForPath,OldBenefitForPath[row]+BenefitForAction[action])
}
}
}
print(paste("I am about to compare all paths of length ",toString(Step)))
print(Paths)
print("They have a benefit of")
print(BenefitForPath)
BestPath=Paths[which.max(BenefitForPath),]
BestPathforStep[Step,]=BestPath
print("I have chosen the path")
print(BestPath)
}
}
#For each look ahead step we have a path
#print(BestPathforStep)
AverageCostforPath=vector(length=NoSteps)
#We now need to see how good they perform
for(i in 1:NoSteps)
{
#We compute the average cost of following such a strategy to decide which paths to pick
#We use determinsitic evolution to the mean state in v
AverageCostforPath[i]=DeterministicCostEvaluationOfPath(BestPathforStep[i,],n,sVec,vVec,CostVec,LambdaVec,bVec,xVec,vMaxVec)$Average
}
print("about to print paths and determinisitic cost of paths")
print(BestPathforStep)
print(AverageCostforPath)
OverallBestPath=BestPathforStep[which.min(AverageCostforPath),]
return(OverallBestPath[1])
}
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(0.5,0.5),c(1,1),c(1.99,1.99))
IndicesForNodes<-function(n,IndexForNodeFunction,sVec,vVec,CostVec,LambdaVec,bVec,xVec,vMaxVec=NULL)
{
if(is.null(vMaxVec))
{
#Create vMaxVec
vMaxVec=CreateVMaxVector(n,LambdaVec,bVec,xVec)
}
#Now for each node we find its index
Indices=vector(length=n)
for(i in 1:n)
{
Indices[i]=IndexForNodeFunction(sVec[i],vVec[i],CostVec[i],LambdaVec[i],bVec[i],xVec[i],vMaxVec[i])
print(Indices[i])
}
return(Indices)
}
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(0.5,0.5),c(1,1),c(1.99,1.99))
Delta<-function(tilde=FALSE,CostAtNode,Lambda,b,x,v,vMax)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
if(tilde==FALSE)
{
#Calculate Sum
Sum=Lambda * R * (B+1)
Sum=Sum+ v * (B+1-TruncPoissonHazard(Lambda,b,v))
if(v>0)
{
for(i in 0:(v-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
print(Sum)
return (Sum)
}
if(tilde==TRUE)
{
#Now calculate sum
Sum= Lambda * (B+1 - R * TruncPoissonHazard(Lambda,b,vMax))
if(vMax>0)
{
for(i in 0:(vMax-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return(Sum)
}
}
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B)
{
return(0)
}
else if(s==B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(0.5,0.5),c(1,1),c(1.99,1.99))
Delta<-function(tilde=FALSE,CostAtNode,Lambda,b,x,v,vMax)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
if(tilde==FALSE)
{
#Calculate Sum
Sum=Lambda * R * (B+1)
Sum=Sum+ v * (B+1-TruncPoissonHazard(Lambda,b,v))
if(v>0)
{
for(i in 0:(v-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
print("This is delta")
print(Sum)
return (Sum)
}
if(tilde==TRUE)
{
#Now calculate sum
Sum= Lambda * (B+1 - R * TruncPoissonHazard(Lambda,b,vMax))
if(vMax>0)
{
for(i in 0:(vMax-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return(Sum)
}
}
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B)
{
return(0)
}
else if(s==B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(0.5,0.5),c(1,1),c(1.99,1.99))
Delta<-function(tilde=FALSE,CostAtNode,Lambda,b,x,v,vMax)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
if(tilde==FALSE)
{
#Calculate Sum
Sum=Lambda * R * (B+1)
Sum=Sum+ v * (B+1-TruncPoissonHazard(Lambda,b,v))
if(v>0)
{
for(i in 0:(v-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
print("This is delta")
print(Sum)
return (Sum)
}
if(tilde==TRUE)
{
#Now calculate sum
Sum= Lambda * (B+1 - R * TruncPoissonHazard(Lambda,b,vMax))
if(vMax>0)
{
for(i in 0:(vMax-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return(Sum)
}
}
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(0.5,0.5),c(1,1),c(1.99,1.99))
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(10,10),c(1,1),c(1.99,1.99))
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(10,10),c(1,1),c(1.99,1.99))
MultiStepBenefitHeuristic(3,2,matrix(rep(1,4),ncol=2,nrow=2),EqualStepIndexForNode,c(1,2),c(1,0),c(1,1),c(0.5,0.5),c(1,1),c(1.99,1.99))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(10,2),rep(1,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(10,2))
SimulationForEvolution(100,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(10,2),rep(1,2),rep(1.9,2))
SimulationForEvolution(10000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(10,2),rep(1,2),rep(1.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(10,2),rep(1,2),rep(1.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(2,2),rep(1,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(2,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(3,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(3,2),rep(1,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(3,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(1,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(4,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(1,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(4,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(2,2),rep(1,2),rep(4,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(2,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(2,2),rep(1,2),rep(4,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(2,2),rep(1.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(3,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(4,2),rep(1,2),rep(4,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(4,2),rep(1.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(4,2),rep(4,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(4,2),rep(1,2),rep(4,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(0.5,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(0.5,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(0.5,2),rep(1,2),rep(1.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(0.5,2),rep(1,2),rep(1.9,2))
Delta<-function(tilde=FALSE,CostAtNode,Lambda,b,x,v,vMax)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
if(tilde==FALSE)
{
#Calculate Sum
Sum=Lambda * R * (B+1)
Sum=Sum+ v * (B+1-TruncPoissonHazard(Lambda,b,v))
if(v>0)
{
for(i in 0:(v-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
print("This is delta")
print(Sum)
return (Sum)
}
if(tilde==TRUE)
{
#Now calculate sum
Sum= Lambda * (B+1 - R * TruncPoissonHazard(Lambda,b,vMax))
if(vMax>0)
{
for(i in 0:(vMax-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return(Sum)
}
}
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(0.5,2),rep(1,2),rep(1.9,2))
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B-1)
{
return(0)
}
else if(s==B-1 && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),PlainIndexForNode,rep(1,2),rep(0.5,2),rep(1,2),rep(1.9,2))
SolveLP(matrix(rep(1,4),nrow=2,ncol=2),2,rep(1.9,2),rep(1,2),rep(1,2),rep(0.5,2))
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B-1)
{
return(0)
}
else if(s==B-1 && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
EqualStepIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s <= B-1 && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax)*(s/(B-1)))
}
else if(s <= B-1 && v >=vMax)
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax)*(s/(B-1)))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(0.5,2),rep(1,2),rep(1.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,2,matrix(rep(1,4),nrow=2,ncol=2,byrow=TRUE),EqualStepIndexForNode,rep(1,2),rep(0.5,2),rep(1,2),rep(2.9,2))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(0.5,3),rep(1,3),rep(1.9,3))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(1.9,3))
SolveLP(matrix(rep(1,9),nrow=3,ncol=3),3,rep(1.9,3),rep(1,3),rep(1,3),rep(1/3,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(1.9,3))
View(EqualStepIndexForNode)
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SolveLP(matrix(rep(1,9),nrow=3,ncol=3),3,rep(2.1,3),rep(1,3),rep(1,3),rep(1/3,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(1000,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SolveLP(matrix(rep(1,9),nrow=3,ncol=3),3,rep(2.1,3),rep(1,3),rep(1,3),rep(1/3,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B)
{
return(0)
}
else if(s==B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
EqualStepIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s <= B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax)*(s/(B)))
}
else if(s <= B && v >=vMax)
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax)*(s/(B)))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
Delta<-function(tilde=FALSE,CostAtNode,Lambda,b,x,v,vMax)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
if(tilde==FALSE)
{
#Calculate Sum
Sum=Lambda * R * (B+1)
Sum=Sum+ v * (B+1-TruncPoissonHazard(Lambda,b,v))
if(v>0)
{
for(i in 0:(v-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
print("This is delta")
print(Sum)
return (Sum)
}
if(tilde==TRUE)
{
#Now calculate sum
Sum= Lambda * (B+1 - R * TruncPoissonHazard(Lambda,b,vMax))
if(vMax>0)
{
for(i in 0:(vMax-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return(Sum)
}
}
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B-1)
{
return(0)
}
else if(s==B-1 && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
EqualStepIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s <= B-1 && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax)*(s/(B-1)))
}
else if(s <= B-1 && v >=vMax)
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax)*(s/(B-1)))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(2,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(2,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(2,3),rep(2.1,3))
SimulationForEvolution(10,3,MultiStepBenefitHeuristic,3,matrix(rep(1,9),nrow=3,ncol=3,byrow=TRUE),EqualStepIndexForNode,rep(1,3),rep(1/3,3),rep(1,3),rep(2.1,3))
