ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
ScenarioRecording[[ScenarioNumber,8]]=Errors
#print(Scenario)
}
return(ScenarioRecording)
}
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,MaxArrivalRateVec,MinCostVec,MaxCostVec)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=8)
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenariosVec(SizeOfCompleteGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,
MaxArrivalRateVec,MinCostVec,MaxCostVec)
print("Generated Scenario")
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
Errors=ScenarioTest$Errors
print(Errors)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
ScenarioRecording[[ScenarioNumber,8]]=Errors
#print(Scenario)
}
return(ScenarioRecording)
}
#This function creates the adjacency matrix for a line graph
CreateLineGraph<-function(NumNodes)
{
AdjacencyMatrix=matrix(0,nrow=NumNodes,ncol=NumNodes)
for(i in 1:NumNodes)
{
if(i==1)
{
AdjacencyMatrix[i,i]=1
AdjacencyMatrix[i,i+1]=1
}
else if(i<NumNodes)
{
AdjacencyMatrix[i,i-1]=1
AdjacencyMatrix[i,i]=1
AdjacencyMatrix[i,i+1]=1
}
else if(i==NumNodes)
{
AdjacencyMatrix[i,i-1]=1
AdjacencyMatrix[i,i]=1
}
}
print(AdjacencyMatrix)
return(AdjacencyMatrix)
}
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosLineGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfLineGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,MaxArrivalRateVec,MinCostVec,MaxCostVec)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=8)
AdjacencyMatrix=CreateLineGraph(SizeOfLineGraph)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenariosVec(SizeOfLineGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,MaxArrivalRateVec,MinCostVec,MaxCostVec)
print("Generated Scenario")
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
Errors=ScenarioTest$Errors
print(Errors)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
ScenarioRecording[[ScenarioNumber,8]]=Errors
#print(Scenario)
}
return(ScenarioRecording)
}
source("Testing Heuristics.R")
library(ggplot2)
library(reshape)
library(tikzDevice)
#This R file contains functions which take in the Test Matrix and return values
#Test Matrices come in the order MinError,BestHeuristics,AdjMatrix,AttackTimes,Capacity,Lambda,Costs,Whole Errors
#This function returns the matrix of errors for one scenario
DecodeTestMatrixErrors<-function(ScenarioNumber,TestMatrix)
{
print(TestMatrix)
print(TestMatrix[ScenarioNumber,8])
return(TestMatrix[ScenarioNumber,8][[1]])
}
#This function just returns the vector of errors for a scenario
DecodeTestVectorErrors<-function(ScenarioNumber,TestMatrix)
{
Matrix=DecodeTestMatrixErrors(ScenarioNumber,TestMatrix)
return(Matrix[,4])
}
#This function collects the test matrix error data for all heuristics per row
DecodeErrorDataPerHeuristic<-function(TestMatrix)
{
#First we form a matrix of errors rows=heuristicnumber,col=scenarionumber
NumberOfScenarios=nrow(TestMatrix)
NumberOfHeuristics=length(DecodeTestVectorErrors(1,TestMatrix))
MatrixOfErrors=matrix(0,nrow=NumberOfHeuristics,ncol=NumberOfScenarios)
for(ScenarioNumber in 1:NumberOfScenarios)
{
VectorOfErrors=DecodeTestVectorErrors(ScenarioNumber,TestMatrix)
MatrixOfErrors[,ScenarioNumber]=VectorOfErrors
}
return(MatrixOfErrors)
}
#This function takes a heuristic vector and categorizes it
CategorizeHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory)
{
#Work out categories
#Note we use the number of categories+1 to allow for the maximum category to be picked
CategoryBoundaries=seq(0,MaxErrorCategory,length.out = NumberOfCategories+1)
MidPointOfCategories=((CategoryBoundaries[2]-CategoryBoundaries[1])/2) + CategoryBoundaries
NumberInEachCategory=vector(length=NumberOfCategories+1)
#Now find out how many are in each category
for(CategoryNum in 1:(NumberOfCategories+1))
{
#Set upper and lower bounds
if(CategoryNum==0)
{
LowerBound=-1
}
else
{
LowerBound=CategoryBoundaries[CategoryNum]
}
if(CategoryNum==(NumberOfCategories+1))
{
UpperBound=Inf
}
else
{
UpperBound=CategoryBoundaries[CategoryNum+1]
}
NumberInEachCategory[CategoryNum]=length(HeuristicErrors[HeuristicErrors>LowerBound & HeuristicErrors<=UpperBound])
}
return(list(CategoryMidPoints=MidPointOfCategories,NumberInEachCategory=NumberInEachCategory))
}
#Plot a single heuristic
PlotHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory)
{
#We run the categorize to get the data to plot
Categorized=CategorizeHeuristicErrorData(HeuristicErrors,NumberOfCategories,MaxErrorCategory)
XCoordinates=Categorized$CategoryMidPoints
YCoordinates=Categorized$NumberInEachCategory
DataFrame=data.frame(XCoordinates,YCoordinates)
Plot<-ggplot(DataFrame,show.legend='True') + geom_point(aes(x = XCoordinates, y = YCoordinates)) +
geom_line(aes(x = XCoordinates, y = YCoordinates))
print(Plot)
return(Plot)
}
#Plot a group of heuristics
#Note the heuristic erros should be provided in a matrix of rows for each heuristic
PlotMultipleHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory,HeuristicNames=NULL,SaveTexImage=F,FileName=NULL,Size=c(3,2))
{
#First we look at how many graphs we are going to plot
NumHeuristics=nrow(HeuristicErrors)
XCoordinates=matrix(0,ncol=length(CategorizeHeuristicErrorData(HeuristicErrors[1,],NumberOfCategories,MaxErrorCategory)$NumberInEachCategory),nrow=NumHeuristics)
YCoordinates=matrix(0,ncol=length(CategorizeHeuristicErrorData(HeuristicErrors[1,],NumberOfCategories,MaxErrorCategory)$NumberInEachCategory),nrow=NumHeuristics)
#Now categorize the data
for(i in 1:NumHeuristics)
{
if(i==1)
{
#Initialize
Categorized=CategorizeHeuristicErrorData(HeuristicErrors[i,],NumberOfCategories,MaxErrorCategory)
YCoordinates=matrix(0,ncol=length(Categorized$NumberInEachCategory),nrow=NumHeuristics)
XCoordinates=Categorized$CategoryMidPoints
YCoordinates[i,]=Categorized$NumberInEachCategory
YCoordinates[i,]=YCoordinates[i,]/sum(YCoordinates[i,])
Ydataframecol<-data.frame(YCoordinates[i,])
if(is.null(HeuristicNames))
{
names(Ydataframecol)=paste("YCoordinates",toString(i))
}
else
{
names(Ydataframecol)=toString(HeuristicNames[i])
}
XYCoordinates=data.frame(XCoordinates)
XYCoordinates<-cbind(XYCoordinates,Ydataframecol)
}
else
{
Categorized=CategorizeHeuristicErrorData(HeuristicErrors[i,],NumberOfCategories,MaxErrorCategory)
YCoordinates[i,]=Categorized$NumberInEachCategory
YCoordinates[i,]=YCoordinates[i,]/sum(YCoordinates[i,])
Ydataframecol<-data.frame(YCoordinates[i,])
if(is.null(HeuristicNames))
{
names(Ydataframecol)=paste("YCoordinates",toString(i))
}
else
{
names(Ydataframecol)=toString(HeuristicNames[i])
}
XYCoordinates<-cbind(XYCoordinates,Ydataframecol)
}
print(XYCoordinates)
}
#Now we plot the data
DataFrame<-XYCoordinates
print(DataFrame)
MeltedDataFrame<-melt(DataFrame,id="XCoordinates")
print(MeltedDataFrame)
if(SaveTexImage)
{
tikz(file=paste("/local/pmxtol/Dropbox/",toString(FileName),".tex",sep=""),width=Size[1],height=Size[2])
}
Plot<-ggplot(MeltedDataFrame,aes(x=XCoordinates,y=value,color=variable),show.legend='True') + #geom_point()+
geom_line() +xlab("Percentage Error")+ylab("Frequency Density") + labs(color="Heuristic Type")
if(SaveTexImage)
{
print(Plot)
dev.off()
}
print(Plot)
return(Plot)
}
RunTestForMultipleScenariosCompleteGraphs(1000,list(MultiStepBenefitHeuristic,MultiStepPenaltyHeuristic),c(1,2,3,4),list(OldPlainIndexForNode,PlainIndexForNode,EqualStepIndexForNode,FlatIndexForNode),500,4,c(1,1,1,1),c(3,3,3,3),c(1,1,1,1),c(1,1,1,1),c(0,0,0,0),c(1,1,1,1),c(1,1,1,1),c(1,1,1,1))
source("Value Iteration approach")
source("Value iteration approach")
source("Value Iteration approach.R")
RunTestForMultipleScenariosCompleteGraphs(1000,list(MultiStepBenefitHeuristic,MultiStepPenaltyHeuristic),c(1,2,3,4),list(OldPlainIndexForNode,PlainIndexForNode,EqualStepIndexForNode,FlatIndexForNode),500,4,c(1,1,1,1),c(3,3,3,3),c(1,1,1,1),c(1,1,1,1),c(0,0,0,0),c(1,1,1,1),c(1,1,1,1),c(1,1,1,1))
load(/maths/pg/pmxtol/Desktop/Link to Git Repositories/Locally-Observable-Patroller-Optimal-Lp/Old.Rdata)
load("/maths/pg/pmxtol/Desktop/Link to Git Repositories/Locally-Observable-Patroller-Optimal-Lp/Old.Rdata")
load("C:/maths/pg/pmxtol/Desktop/Link to Git Repositories/Locally-Observable-Patroller-Optimal-Lp/Old.Rdata")
load("/maths/pg/pmxtol/Desktop/Link to Git Repositories/Locally-Observable-Patroller-Optimal-Lp/Old.RData")
setwd("~/Documents/Git Repositories/Locally-Observable-Patroller-Optimal-Lp")
PlotMultipleHeuristicErrorData(DecodeTestDataPerHeuristic(DataForReport)[c(1,3,5)],100,100,c("PH(1)","PH(2)","PH(3)"),T,OldPlainPenaltyHeuristicOnComplete,c(5,3))
#Plot a group of heuristics
#Note the heuristic erros should be provided in a matrix of rows for each heuristic
PlotMultipleHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory,HeuristicNames=NULL,SaveTexImage=F,FileName=NULL,Size=c(3,2))
{
#First we look at how many graphs we are going to plot
NumHeuristics=nrow(HeuristicErrors)
XCoordinates=matrix(0,ncol=length(CategorizeHeuristicErrorData(HeuristicErrors[1,],NumberOfCategories,MaxErrorCategory)$NumberInEachCategory),nrow=NumHeuristics)
YCoordinates=matrix(0,ncol=length(CategorizeHeuristicErrorData(HeuristicErrors[1,],NumberOfCategories,MaxErrorCategory)$NumberInEachCategory),nrow=NumHeuristics)
#Now categorize the data
for(i in 1:NumHeuristics)
{
if(i==1)
{
#Initialize
Categorized=CategorizeHeuristicErrorData(HeuristicErrors[i,],NumberOfCategories,MaxErrorCategory)
YCoordinates=matrix(0,ncol=length(Categorized$NumberInEachCategory),nrow=NumHeuristics)
XCoordinates=Categorized$CategoryMidPoints
YCoordinates[i,]=Categorized$NumberInEachCategory
YCoordinates[i,]=YCoordinates[i,]/sum(YCoordinates[i,])
Ydataframecol<-data.frame(YCoordinates[i,])
if(is.null(HeuristicNames))
{
names(Ydataframecol)=paste("YCoordinates",toString(i))
}
else
{
names(Ydataframecol)=toString(HeuristicNames[i])
}
XYCoordinates=data.frame(XCoordinates)
XYCoordinates<-cbind(XYCoordinates,Ydataframecol)
}
else
{
Categorized=CategorizeHeuristicErrorData(HeuristicErrors[i,],NumberOfCategories,MaxErrorCategory)
YCoordinates[i,]=Categorized$NumberInEachCategory
YCoordinates[i,]=YCoordinates[i,]/sum(YCoordinates[i,])
Ydataframecol<-data.frame(YCoordinates[i,])
if(is.null(HeuristicNames))
{
names(Ydataframecol)=paste("YCoordinates",toString(i))
}
else
{
names(Ydataframecol)=toString(HeuristicNames[i])
}
XYCoordinates<-cbind(XYCoordinates,Ydataframecol)
}
print(XYCoordinates)
}
#Now we plot the data
DataFrame<-XYCoordinates
print(DataFrame)
MeltedDataFrame<-melt(DataFrame,id="XCoordinates")
print(MeltedDataFrame)
if(SaveTexImage)
{
tikz(file=paste("/local/pmxtol/Dropbox/",toString(FileName),".tex",sep=""),width=Size[1],height=Size[2])
}
Plot<-ggplot(MeltedDataFrame,aes(x=XCoordinates,y=value,color=variable),show.legend='True') + #geom_point()+
geom_line() +xlab("Percentage Error")+ylab("Frequency Density") + labs(color="Heuristic Type")
if(SaveTexImage)
{
print(Plot)
dev.off()
}
print(Plot)
return(Plot)
}
PlotMultipleHeuristicErrorData(DecodeTestDataPerHeuristic(DataForReport)[c(1,3,5)],100,100,c("PH(1)","PH(2)","PH(3)"),T,OldPlainPenaltyHeuristicOnComplete,c(5,3))
source("Testing Heuristics.R")
library(ggplot2)
library(reshape)
library(tikzDevice)
#This R file contains functions which take in the Test Matrix and return values
#Test Matrices come in the order MinError,BestHeuristics,AdjMatrix,AttackTimes,Capacity,Lambda,Costs,Whole Errors
#This function returns the matrix of errors for one scenario
DecodeTestMatrixErrors<-function(ScenarioNumber,TestMatrix)
{
print(TestMatrix)
print(TestMatrix[ScenarioNumber,8])
return(TestMatrix[ScenarioNumber,8][[1]])
}
#This function just returns the vector of errors for a scenario
DecodeTestVectorErrors<-function(ScenarioNumber,TestMatrix)
{
Matrix=DecodeTestMatrixErrors(ScenarioNumber,TestMatrix)
return(Matrix[,4])
}
#This function collects the test matrix error data for all heuristics per row
DecodeErrorDataPerHeuristic<-function(TestMatrix)
{
#First we form a matrix of errors rows=heuristicnumber,col=scenarionumber
NumberOfScenarios=nrow(TestMatrix)
NumberOfHeuristics=length(DecodeTestVectorErrors(1,TestMatrix))
MatrixOfErrors=matrix(0,nrow=NumberOfHeuristics,ncol=NumberOfScenarios)
for(ScenarioNumber in 1:NumberOfScenarios)
{
VectorOfErrors=DecodeTestVectorErrors(ScenarioNumber,TestMatrix)
MatrixOfErrors[,ScenarioNumber]=VectorOfErrors
}
return(MatrixOfErrors)
}
#This function takes a heuristic vector and categorizes it
CategorizeHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory)
{
#Work out categories
#Note we use the number of categories+1 to allow for the maximum category to be picked
CategoryBoundaries=seq(0,MaxErrorCategory,length.out = NumberOfCategories+1)
MidPointOfCategories=((CategoryBoundaries[2]-CategoryBoundaries[1])/2) + CategoryBoundaries
NumberInEachCategory=vector(length=NumberOfCategories+1)
#Now find out how many are in each category
for(CategoryNum in 1:(NumberOfCategories+1))
{
#Set upper and lower bounds
if(CategoryNum==0)
{
LowerBound=-1
}
else
{
LowerBound=CategoryBoundaries[CategoryNum]
}
if(CategoryNum==(NumberOfCategories+1))
{
UpperBound=Inf
}
else
{
UpperBound=CategoryBoundaries[CategoryNum+1]
}
NumberInEachCategory[CategoryNum]=length(HeuristicErrors[HeuristicErrors>LowerBound & HeuristicErrors<=UpperBound])
}
return(list(CategoryMidPoints=MidPointOfCategories,NumberInEachCategory=NumberInEachCategory))
}
#Plot a single heuristic
PlotHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory)
{
#We run the categorize to get the data to plot
Categorized=CategorizeHeuristicErrorData(HeuristicErrors,NumberOfCategories,MaxErrorCategory)
XCoordinates=Categorized$CategoryMidPoints
YCoordinates=Categorized$NumberInEachCategory
DataFrame=data.frame(XCoordinates,YCoordinates)
Plot<-ggplot(DataFrame,show.legend='True') + geom_point(aes(x = XCoordinates, y = YCoordinates)) +
geom_line(aes(x = XCoordinates, y = YCoordinates))
print(Plot)
return(Plot)
}
#Plot a group of heuristics
#Note the heuristic erros should be provided in a matrix of rows for each heuristic
PlotMultipleHeuristicErrorData<-function(HeuristicErrors,NumberOfCategories,MaxErrorCategory,HeuristicNames=NULL,SaveTexImage=F,FileName=NULL,Size=c(3,2))
{
#First we look at how many graphs we are going to plot
NumHeuristics=nrow(HeuristicErrors)
XCoordinates=matrix(0,ncol=length(CategorizeHeuristicErrorData(HeuristicErrors[1,],NumberOfCategories,MaxErrorCategory)$NumberInEachCategory),nrow=NumHeuristics)
YCoordinates=matrix(0,ncol=length(CategorizeHeuristicErrorData(HeuristicErrors[1,],NumberOfCategories,MaxErrorCategory)$NumberInEachCategory),nrow=NumHeuristics)
#Now categorize the data
for(i in 1:NumHeuristics)
{
if(i==1)
{
#Initialize
Categorized=CategorizeHeuristicErrorData(HeuristicErrors[i,],NumberOfCategories,MaxErrorCategory)
YCoordinates=matrix(0,ncol=length(Categorized$NumberInEachCategory),nrow=NumHeuristics)
XCoordinates=Categorized$CategoryMidPoints
YCoordinates[i,]=Categorized$NumberInEachCategory
YCoordinates[i,]=YCoordinates[i,]/sum(YCoordinates[i,])
Ydataframecol<-data.frame(YCoordinates[i,])
if(is.null(HeuristicNames))
{
names(Ydataframecol)=paste("YCoordinates",toString(i))
}
else
{
names(Ydataframecol)=toString(HeuristicNames[i])
}
XYCoordinates=data.frame(XCoordinates)
XYCoordinates<-cbind(XYCoordinates,Ydataframecol)
}
else
{
Categorized=CategorizeHeuristicErrorData(HeuristicErrors[i,],NumberOfCategories,MaxErrorCategory)
YCoordinates[i,]=Categorized$NumberInEachCategory
YCoordinates[i,]=YCoordinates[i,]/sum(YCoordinates[i,])
Ydataframecol<-data.frame(YCoordinates[i,])
if(is.null(HeuristicNames))
{
names(Ydataframecol)=paste("YCoordinates",toString(i))
}
else
{
names(Ydataframecol)=toString(HeuristicNames[i])
}
XYCoordinates<-cbind(XYCoordinates,Ydataframecol)
}
print(XYCoordinates)
}
#Now we plot the data
DataFrame<-XYCoordinates
print(DataFrame)
MeltedDataFrame<-melt(DataFrame,id="XCoordinates")
print(MeltedDataFrame)
if(SaveTexImage)
{
tikz(file=paste("/local/pmxtol/Dropbox/",toString(FileName),".tex",sep=""),width=Size[1],height=Size[2])
}
Plot<-ggplot(MeltedDataFrame,aes(x=XCoordinates,y=value,color=variable),show.legend='True') + #geom_point()+
geom_line() +xlab("Percentage Error")+ylab("Frequency Density") + labs(color="Heuristic Type")
if(SaveTexImage)
{
print(Plot)
dev.off()
}
print(Plot)
return(Plot)
}
PlotMultipleHeuristicErrorData(DecodeTestDataPerHeuristic(DataForReport)[c(1,3,5)],100,100,c("PH(1)","PH(2)","PH(3)"),T,OldPlainPenaltyHeuristicOnComplete,c(5,3))
PlotMultipleHeuristicErrorData(DecodeErrorDataPerHeuristic(DataForReport)[c(1,3,5)],100,100,c("PH(1)","PH(2)","PH(3)"),T,OldPlainPenaltyHeuristicOnComplete,c(5,3))
PlotMultipleHeuristicErrorData(DecodeErrorDataPerHeuristic(DataForReport)[c(1,3,5),],100,100,c("PH(1)","PH(2)","PH(3)"),T,OldPlainPenaltyHeuristicOnComplete,c(5,3))
View(DataForReport)
DataForReport2=RunTestForMultipleScenariosCompleteGraphs(500,list(MultiStepBenefitHeuristic,MultiStepPenaltyHeuristic),c(1,2,3,4),list(OldPlainIndexForNode,PlainIndexForNode,EqualStepIndexForNode,FlatIndexForNode),500,4,c(1,1,1,1),c(3,3,3,3),c(1,1,1,1),c(1,1,1,1),c(0,0,0,0),c(1,1,1,1),c(1,1,1,1),c(1,1,1,1))
DataForReport2=RunTestForMultipleScenariosCompleteGraphs(500,list(MultiStepBenefitHeuristic,MultiStepPenaltyHeuristic),c(1,2,3,4),list(OldPlainIndexForNode,PlainIndexForNode,EqualStepIndexForNode,FlatIndexForNode),500,4,c(1,1,1,1),c(3,3,3,3),c(1,1,1,1),c(1,1,1,1),c(0,0,0,0),c(1,1,1,1),c(1,1,1,1),c(1,1,1,1))
source("Testing Heuristics.R")
library(ggplot2)
library(reshape)
library(tikzDevice)
source("Testing Heuristics.R")
library(ggplot2)
library(reshape)
library(tikzDevice)
DataForReport2=RunTestForMultipleScenariosCompleteGraphs(500,list(MultiStepBenefitHeuristic,MultiStepPenaltyHeuristic),c(1,2,3,4),list(OldPlainIndexForNode,PlainIndexForNode,EqualStepIndexForNode,FlatIndexForNode),500,4,c(1,1,1,1),c(3,3,3,3),c(1,1,1,1),c(1,1,1,1),c(0,0,0,0),c(1,1,1,1),c(1,1,1,1),c(1,1,1,1))
View(DataForReport2)
DataForReport3=RunTestForMultipleScenariosLineGraphs(500,list(MultiStepBenefitHeuristic,MultiStepPenaltyHeuristic),c(1,2,3,4),list(OldPlainIndexForNode,PlainIndexForNode,EqualStepIndexForNode,FlatIndexForNode),500,4,c(1,1,1,1),c(3,3,3,3),c(1,1,1,1),c(1,1,1,1),c(0,0,0,0),c(1,1,1,1),c(1,1,1,1),c(1,1,1,1))
DecodedReportData2=DecodeErrorDataPerHeuristic(DataForReport2)
DecodedReportData3=DecodeErrorDataPerHeuristic(DataForReport3)
PlotMultipleHeuristicErrorData(DecodedReportData2,100,100)
PlotMultipleHeuristicErrorData(DecodedReportData3,100,100)
View(FullInfo)
View(FullInfo)
source("Testing Heuristics.R")
library(ggplot2)
library(reshape)
library(tikzDevice)
PlotMultipleHeuristicErrorData(DecodedReportData2[1,2,3,4],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData2[c(1,2,3,4),],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData2[c(17,18),],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData3[c(17,18),],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData2[c(25,26),],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData2[c(1,5,9,13,17,21,25,29),],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData2[c(1,5,9,17,21,25),],100,100)
PlotMultipleHeuristicErrorData(DecodedReportData2[c(1,5,9,17,21,25),],100,100,HeuristicNames = c("BH($1$)","BH($2$)","BH($3$)","PH($1$)","PH($2$)","PH($3$)"),SaveTexImage = T,FileName = BHvsPHInitialPlain,size=c(5,3))
PlotMultipleHeuristicErrorData(DecodedReportData2[c(1,5,9,17,21,25),],100,100,HeuristicNames = c("BH($1$)","BH($2$)","BH($3$)","PH($1$)","PH($2$)","PH($3$)"),SaveTexImage = T,FileName = BHvsPHInitialPlain,Size=c(5,3))
PlotMultipleHeuristicErrorData(DecodedReportData2[c(1,5,9,17,21,25),],100,100,HeuristicNames = c("BH($1$)","BH($2$)","BH($3$)","PH($1$)","PH($2$)","PH($3$)"),SaveTexImage = T,FileName = "BHvsPHInitialPlain",Size=c(5,3))
PlotMultipleHeuristicErrorData(DecodedReportData2[c(2,6,10,18,22,26),],100,100,HeuristicNames = c("BH($1$)","BH($2$)","BH($3$)","PH($1$)","PH($2$)","PH($3$)"),SaveTexImage = T,FileName = "BHvsPHNewPlainComplete",Size=c(5,3))
