AdjacencyMatrix=Scenario$AdjacencyMatrix
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
Errors=ScenarioTest$Errors
print(Errors)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
ScenarioRecording[[ScenarioNumber,8]]=Errors
#print(Scenario)
}
return(ScenarioRecording)
}
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,MaxArrivalRateVec,MinCostVec,MaxCostVec)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=8)
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenariosVec(SizeOfCompleteGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,
MaxArrivalRateVec,MinCostVec,MaxCostVec)
print("Generated Scenario")
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
Errors=ScenarioTest$Errors
print(Errors)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
ScenarioRecording[[ScenarioNumber,8]]=Errors
#print(Scenario)
}
return(ScenarioRecording)
}
#This function creates the adjacency matrix for a line graph
CreateLineGraph<-function(NumNodes)
{
AdjacencyMatrix=matrix(0,nrow=NumNodes,ncol=NumNodes)
for(i in 1:NumNodes)
{
if(i==1)
{
AdjacencyMatrix[i,i]=1
AdjacencyMatrix[i,i+1]=1
}
else if(i<NumNodes)
{
AdjacencyMatrix[i,i-1]=1
AdjacencyMatrix[i,i]=1
AdjacencyMatrix[i,i+1]=1
}
else if(i==NumNodes)
{
AdjacencyMatrix[i,i-1]=1
AdjacencyMatrix[i,i]=1
}
}
print(AdjacencyMatrix)
return(AdjacencyMatrix)
}
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosLineGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfLineGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,MaxArrivalRateVec,MinCostVec,MaxCostVec)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=8)
AdjacencyMatrix=CreateLineGraph(SizeOfLineGraph)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenariosVec(SizeOfLineGraph,MinAttackTimeVec,MaxAttackTimeVec,MinObservedSizeVec,MaxObservedSizeVec,MinArrivalRateVec,MaxArrivalRateVec,MinCostVec,MaxCostVec)
print("Generated Scenario")
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
Errors=ScenarioTest$Errors
print(Errors)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
ScenarioRecording[[ScenarioNumber,8]]=Errors
#print(Scenario)
}
return(ScenarioRecording)
}
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
View(RunTest2)
View(RunTest2)
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
View(RunTest2)
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
View(RunTest2)
ValueIterationForPolicy<-function(MaxNoSteps,Tolerance,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,Policy,PrintOutput=TRUE)
{
step=1
BoundWidthError=Tolerance+1
PriorValueFunction=ValueFunctionForPolicy(0,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,Policy)
while(step<=MaxNoSteps && BoundWidthError>=Tolerance)
{
if(PrintOutput)
{
print(paste("On Step ",toString(step)))
}
#Work out the value vector for this number of steps
NewValueFunction=ValueFunctionForPolicy(step,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,Policy,PriorValueFunction)
#For this state calcluate min and max for all states
CostBetweenSteps=NewValueFunction-PriorValueFunction
MaxForStates=max(CostBetweenSteps)
MinForStates=min(CostBetweenSteps)
#print(NewValueFunction)
#print(CostBetweenSteps)
BoundWidth=MaxForStates-MinForStates
if(BoundWidth==0)
{
BoundWidthError=0
}
else
{
BoundWidthError=BoundWidth/MinForStates
}
step=step+1
PriorValueFunction=NewValueFunction
if(PrintOutput)
{
print(MinForStates)
print(MaxForStates)
}
}
if(BoundWidthError<Tolerance)
{
if(PrintOutput)
{
print("Returning due to tolerance reached")
}
return(list(LowerBound=MinForStates,UpperBound=MaxForStates,ValueFunction=NewValueFunction,StepsRun=step-1))
}
else
{
if(PrintOutput)
{
print("Returning due to time out")
}
return(list(LowerBound=MinForStates,UpperBound=MaxForStates,ValueFunction=NewValueFunction,StepsRun=step-1))
}
}
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
mean(c(78,90,123))
mean(c(78,90,123))/100
#The aim of this function is to the run the test (on a scenario) for multiple heuristics
RunTestForMultipleHeuristics<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,
MaxStepsForIteration,PrintOutput=TRUE)
{
NumberOfHeuristicFuncs=length(ListOfHeuristicFunctions)
NumberOfHeuristicsDepths=length(ListOfHeuristicDepths)
NumberOfIndexFuncs=length(ListOfIndexForNodeFunctions)
#We solve the dual problem once
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(PrintOutput)
{
print("We are going to solve the dual problem first")
}
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
if(PrintOutput)
{
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
if(DualObjectiveValue>0)
{
ToleranceForIt=10^floor(log10(DualObjectiveValue)-4)
}
else
{
ToleranceForIt=10^floor(-1000)
}
#Create Storage for errors
Errors=matrix(0,ncol=4,nrow=NumberOfHeuristicFuncs*NumberOfHeuristicsDepths*NumberOfIndexFuncs)
PolicyList=list() #Note this list is a list of lists
counter=1
for(HeuristicFuncNum in 1:NumberOfHeuristicFuncs)
{
for(HeuristicDepthNum in 1:NumberOfHeuristicsDepths)
{
for(IndexFuncNum in 1:NumberOfIndexFuncs)
{
#We now form the policy for the heuristic, at the depth , using the index
if(PrintOutput)
{
print(paste("We are in heurisitic func:",toString(HeuristicFuncNum),
" depth:",toString(HeuristicDepthNum)," index type:",toString(IndexFuncNum)))
print("We are creating the Heuristic Policy")
}
PolicyByHeuristic=HeuristicPolicy(ListOfHeuristicDepths[HeuristicDepthNum],ListOfHeuristicFunctions[[HeuristicFuncNum]],
n,AdjacencyMatrix,ListOfIndexForNodeFunctions[[IndexFuncNum]],CostVec,LambdaVec,bVec,xVec,StateSpace)
if(PrintOutput)
{
print("Policy Has been created")
}
#Run the heuristic
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
print(ValueFuncByHeuristic)
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
if(PrintOutput)
{
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
}
Errors[counter,1]=HeuristicFuncNum
Errors[counter,2]=HeuristicDepthNum
Errors[counter,3]=IndexFuncNum
Errors[counter,4]=PercentageError
PolicyList[[counter]]=PolicyByHeuristic
#print(PolicyList)
counter=counter+1
}
}
}
#It is worth noting that by the ordering the structure is BigBlocks (with heuristic func), small blocks (with heuristic depth) and elements (with index func)
#Now identify the best Heuristic
MinError=min(Errors[,4])
IDBestHeurisitic=which(Errors[,4]==MinError)
print(IDBestHeurisitic)
BestHeuristics=Errors[IDBestHeurisitic,1:3]
return(list(Errors=Errors,MinError=MinError,BestHeuristics=BestHeuristics))
}
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,4,rep(0,4),rep(3,4),rep(0,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,4,rep(0,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(0,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
ValueIterationForPolicy<-function(MaxNoSteps,Tolerance,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,Policy,PrintOutput=FALSE)
{
step=1
BoundWidthError=Tolerance+1
PriorValueFunction=ValueFunctionForPolicy(0,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,Policy)
while(step<=MaxNoSteps && BoundWidthError>=Tolerance)
{
if(PrintOutput)
{
print(paste("On Step ",toString(step)))
}
#Work out the value vector for this number of steps
NewValueFunction=ValueFunctionForPolicy(step,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,Policy,PriorValueFunction)
#For this state calcluate min and max for all states
CostBetweenSteps=NewValueFunction-PriorValueFunction
MaxForStates=max(CostBetweenSteps)
MinForStates=min(CostBetweenSteps)
#print(NewValueFunction)
#print(CostBetweenSteps)
BoundWidth=MaxForStates-MinForStates
if(BoundWidth==0)
{
BoundWidthError=0
}
else
{
BoundWidthError=BoundWidth/MinForStates
}
step=step+1
PriorValueFunction=NewValueFunction
if(PrintOutput)
{
print(MinForStates)
print(MaxForStates)
}
}
if(BoundWidthError<Tolerance)
{
if(PrintOutput)
{
print("Returning due to tolerance reached")
}
return(list(LowerBound=MinForStates,UpperBound=MaxForStates,ValueFunction=NewValueFunction,StepsRun=step-1))
}
else
{
if(PrintOutput)
{
print("Returning due to time out")
}
return(list(LowerBound=MinForStates,UpperBound=MaxForStates,ValueFunction=NewValueFunction,StepsRun=step-1))
}
}
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
#The aim of this function is to the run the test (on a scenario) for multiple heuristics
RunTestForMultipleHeuristics<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,
MaxStepsForIteration,PrintOutput=TRUE)
{
NumberOfHeuristicFuncs=length(ListOfHeuristicFunctions)
NumberOfHeuristicsDepths=length(ListOfHeuristicDepths)
NumberOfIndexFuncs=length(ListOfIndexForNodeFunctions)
#We solve the dual problem once
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(PrintOutput)
{
print("We are going to solve the dual problem first")
}
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
if(PrintOutput)
{
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
if(DualObjectiveValue>0)
{
ToleranceForIt=10^floor(log10(DualObjectiveValue)-4)
}
else
{
ToleranceForIt=10^floor(-1000)
}
#Create Storage for errors
Errors=matrix(0,ncol=4,nrow=NumberOfHeuristicFuncs*NumberOfHeuristicsDepths*NumberOfIndexFuncs)
PolicyList=list() #Note this list is a list of lists
counter=1
for(HeuristicFuncNum in 1:NumberOfHeuristicFuncs)
{
for(HeuristicDepthNum in 1:NumberOfHeuristicsDepths)
{
for(IndexFuncNum in 1:NumberOfIndexFuncs)
{
#We now form the policy for the heuristic, at the depth , using the index
if(PrintOutput)
{
print(paste("We are in heurisitic func:",toString(HeuristicFuncNum),
" depth:",toString(HeuristicDepthNum)," index type:",toString(IndexFuncNum)))
print("We are creating the Heuristic Policy")
}
PolicyByHeuristic=HeuristicPolicy(ListOfHeuristicDepths[HeuristicDepthNum],ListOfHeuristicFunctions[[HeuristicFuncNum]],
n,AdjacencyMatrix,ListOfIndexForNodeFunctions[[IndexFuncNum]],CostVec,LambdaVec,bVec,xVec,StateSpace)
if(PrintOutput)
{
print("Policy Has been created")
}
#Run the heuristic
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
if(PrintOutput)
{
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
}
Errors[counter,1]=HeuristicFuncNum
Errors[counter,2]=HeuristicDepthNum
Errors[counter,3]=IndexFuncNum
Errors[counter,4]=PercentageError
PolicyList[[counter]]=PolicyByHeuristic
#print(PolicyList)
counter=counter+1
}
}
}
#It is worth noting that by the ordering the structure is BigBlocks (with heuristic func), small blocks (with heuristic depth) and elements (with index func)
#Now identify the best Heuristic
MinError=min(Errors[,4])
IDBestHeurisitic=which(Errors[,4]==MinError)
print(IDBestHeurisitic)
BestHeuristics=Errors[IDBestHeurisitic,1:3]
return(list(Errors=Errors,MinError=MinError,BestHeuristics=BestHeuristics))
}
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
#The aim of this function is to the run the test (on a scenario) for multiple heuristics
RunTestForMultipleHeuristics<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,
MaxStepsForIteration,PrintOutput=TRUE)
{
NumberOfHeuristicFuncs=length(ListOfHeuristicFunctions)
NumberOfHeuristicsDepths=length(ListOfHeuristicDepths)
NumberOfIndexFuncs=length(ListOfIndexForNodeFunctions)
#We solve the dual problem once
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(PrintOutput)
{
print("We are going to solve the dual problem first")
}
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
if(PrintOutput)
{
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
if(DualObjectiveValue>0)
{
ToleranceForIt=10^floor(log10(DualObjectiveValue)-6)
}
else
{
ToleranceForIt=10^floor(-1000)
}
#Create Storage for errors
Errors=matrix(0,ncol=4,nrow=NumberOfHeuristicFuncs*NumberOfHeuristicsDepths*NumberOfIndexFuncs)
PolicyList=list() #Note this list is a list of lists
counter=1
for(HeuristicFuncNum in 1:NumberOfHeuristicFuncs)
{
for(HeuristicDepthNum in 1:NumberOfHeuristicsDepths)
{
for(IndexFuncNum in 1:NumberOfIndexFuncs)
{
#We now form the policy for the heuristic, at the depth , using the index
if(PrintOutput)
{
print(paste("We are in heurisitic func:",toString(HeuristicFuncNum),
" depth:",toString(HeuristicDepthNum)," index type:",toString(IndexFuncNum)))
print("We are creating the Heuristic Policy")
}
PolicyByHeuristic=HeuristicPolicy(ListOfHeuristicDepths[HeuristicDepthNum],ListOfHeuristicFunctions[[HeuristicFuncNum]],
n,AdjacencyMatrix,ListOfIndexForNodeFunctions[[IndexFuncNum]],CostVec,LambdaVec,bVec,xVec,StateSpace)
if(PrintOutput)
{
print("Policy Has been created")
}
#Run the heuristic
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
if(PrintOutput)
{
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
}
Errors[counter,1]=HeuristicFuncNum
Errors[counter,2]=HeuristicDepthNum
Errors[counter,3]=IndexFuncNum
Errors[counter,4]=PercentageError
PolicyList[[counter]]=PolicyByHeuristic
#print(PolicyList)
counter=counter+1
}
}
}
#It is worth noting that by the ordering the structure is BigBlocks (with heuristic func), small blocks (with heuristic depth) and elements (with index func)
#Now identify the best Heuristic
MinError=min(Errors[,4])
IDBestHeurisitic=which(Errors[,4]==MinError)
print(IDBestHeurisitic)
BestHeuristics=Errors[IDBestHeurisitic,1:3]
return(list(Errors=Errors,MinError=MinError,BestHeuristics=BestHeuristics))
}
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
RunTest2=RunTestForMultipleScenariosLineGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,500,4,rep(1,4),rep(3,4),rep(1,4),rep(1,4),rep(0,4),rep(1,4),rep(1,4),rep(1,4))
