{
#Setting initial sequences
StateMatrix=matrix(nrow=(b+1),ncol=n)
for(i in 1:(b+1))
{
StateMatrix[i,1]=i-1
}
for(j in 2:n)
{
TempMatrix=matrix(nrow=0,ncol=n)
#Copy prior sequence
for(row in 1:nrow(StateMatrix))
{
BlockMatrix=matrix(rep(StateMatrix[row,],b+1),nrow=(b+1),ncol=n,byrow = TRUE)
TempMatrix=rbind(TempMatrix,BlockMatrix)
}
#now for each row in the Temp Matrix we add 0,..,b
for(row in 1:nrow(TempMatrix))
{
TempMatrix[row,j]=(row-1) %% (b+1)
}
StateMatrix=TempMatrix
#print(StateMatrix)
}
return(StateMatrix)
}
CreateVStates<-function(n,bVec)
{
#Setting initial sequences
StateMatrix=matrix(nrow=(bVec[1]+1),ncol=n)
for(i in 1:(bVec[1]+1))
{
StateMatrix[i,1]=i-1
}
for(j in 2:n)
{
TempMatrix=matrix(nrow=0,ncol=n)
#Copy prior sequence
for(row in 1:nrow(StateMatrix))
{
BlockMatrix=matrix(rep(StateMatrix[row,],bVec[j]+1),nrow=(bVec[j]+1),ncol=n,byrow = TRUE)
TempMatrix=rbind(TempMatrix,BlockMatrix)
}
#now for each row in the Temp Matrix we add 0,..,b
for(row in 1:nrow(TempMatrix))
{
TempMatrix[row,j]=(row-1) %% (bVec[j]+1)
}
StateMatrix=TempMatrix
#print(StateMatrix)
}
return(StateMatrix)
}
CreateSVStatesForConstantBb<-function(n,B,b)
{
SStates=CreateSStatesForConstantB(n,B)
VStates=CreateVStatesForConstantb(n,b)
#Then for each row in SStates we all all rows in V states to be added
FullStateSpace=matrix(nrow=(nrow(SStates)*nrow(VStates)),ncol=2*n)
for(i in 1:nrow(FullStateSpace))
{
#split i into its Block and remainder
Block=ceiling(i/nrow(VStates))
Remainder=((i-1) %% nrow(VStates)) +1
FullStateSpace[i,1:n]=SStates[Block,]
#Before we can insert the VState, we need to check that if s=B+2, then we set v=0
WorkingVState=VStates[Remainder,]
for(j in 1:n)
{
if(FullStateSpace[i,j]==B+2)
{
WorkingVState[j]=0
}
}
FullStateSpace[i,(n+1):(2*n)]=WorkingVState
}
FullStateSpace=unique(FullStateSpace)
return(FullStateSpace)
}
CreateSVStates<-function(n,BVec,bVec)
{
SStates=CreateSStates(n,BVec)
VStates=CreateVStates(n,bVec)
#Then for each row in SStates we all all rows in V states to be added
FullStateSpace=matrix(nrow=(nrow(SStates)*nrow(VStates)),ncol=2*n)
for(i in 1:nrow(FullStateSpace))
{
#split i into its Block and remainder
Block=ceiling(i/nrow(VStates))
Remainder=((i-1) %% nrow(VStates)) +1
FullStateSpace[i,1:n]=SStates[Block,]
#Before we can insert the VState, we need to check that if s=B+2, then we set v=0
WorkingVState=VStates[Remainder,]
for(j in 1:n)
{
if(FullStateSpace[i,j]==BVec[j]+2)
{
WorkingVState[j]=0
}
}
FullStateSpace[i,(n+1):(2*n)]=WorkingVState
}
FullStateSpace=unique(FullStateSpace)
return(FullStateSpace)
}
# #create function for expectation of evolved state
# ListOfEvolvedState<-function(StateVector,NodeMovedTo,n,B,b)
# {
#   #for each state and action we evolve to b+1 possible states (0,...,b)
#   NewStateVector<-StateVector
#
#   #Evolve the s state part
#   for(i in 1:n)
#   {
#     if(i==NodeMovedto)
#     {
#       NewStateVector[i]=1
#     }
#     else
#     {
#       NewStateVector[i]=min(NewStateVector[i]+1,B+1)
#     }
#   }
#
#   NewStatesMatrix=matrix(nrow=b+1,ncol=2*n)
#   for(i in 1:(b+1))
#   {
#     NewStatesMatrix[i,]=NewStateVector
#     NewStatesMatrix[i,NodeMovedto]=i-1
#   }
#
#   return(NewStatesMatrix)
# }
#
# ListOfEvolvedStateIDs<-function(StateVector,NodeMovedTo,n,B,b)
# {
#   NewStatesMatrix=ListOfEvolvedState(StateVector,NodeMovedTo,n,B,b)
#   EvolvedIDs=vector(length=b+1)
#   for(i in 1:(b+1))
#   {
#     EvolvedIDs[i]=StateNumberID(NewStatesMatrix[i,])
#   }
#
#   return(EvolvedIDs)
# }
#Evolution of S states function
NewSState<-function(CurrentSState,NodeMovedTo,BVec)
{
NewSState=vector(length=length(CurrentSState))
for(i in 1:length(CurrentSState))
{
if(i==NodeMovedTo)
{
NewSState[i]=1
}
else
{
NewSState[i]=min(CurrentSState[i]+1,BVec[i]+2)
}
}
return(NewSState)
}
#Evolution of V States function
#note. We need to know the current S state , as if one value is B+2, then v is set to 0
NewVState<-function(CurrentVState,NewSState,NodeMovedTo,BVec,bVec,lambdaVec)
{
#We aim to store the New V states and the probability of ending up in one.
NewVState=matrix(nrow=(bVec[NodeMovedTo]+1),ncol=length(CurrentVState))
NewVStateProb=vector(length=(bVec[NodeMovedTo]+1))
WorkingVState=CurrentVState
#We now need to set any v=0 if there s=B+2
for(i in 1:length(NewSState))
{
if(NewSState[i]==BVec[i]+2)
{
WorkingVState[i]=0
}
}
for(i in 1:(bVec[NodeMovedTo]+1))
{
#copy the current state
NewVState[i,]=WorkingVState
#Store the new evolved value
NewVState[i,NodeMovedTo]=(i-1)
#Also store the probability in a vector
NewVStateProb[i]=TruncPoissonPMF(lambdaVec[NodeMovedTo],bVec[NodeMovedTo],i-1)
}
return(list(State=NewVState,Prob=NewVStateProb))
}
#Evolution of SV States
NewSVState<-function(CurrentSVState,NodeMovedTo,BVec,bVec,lambdaVec)
{
#Get seperate information from prior functions
n=length(CurrentSVState)/2
NewSState=NewSState(CurrentSVState[1:n],NodeMovedTo,BVec)
NewVStates=NewVState(CurrentSVState[(n+1):(2*n)],NewSState,NodeMovedTo,BVec,bVec,lambdaVec)$State
NewVStatesProbs=NewVState(CurrentSVState[(n+1):(2*n)],NewSState,NodeMovedTo,BVec,bVec,lambdaVec)$Prob
#Rejoin the S and V together
NewSVState=matrix(nrow=(bVec[NodeMovedTo]+1),ncol=(2*n))
for(i in 1:(bVec[NodeMovedTo]+1))
{
NewSVState[i,1:n]=NewSState
NewSVState[i,(n+1):(2*n)]=NewVStates[i,]
}
return(list(State=NewSVState,Prob=NewVStatesProbs))
}
#Identify the row which a vector comes from
IdenityRow<-function(Vec,Mat)
{
for(i in 1:nrow(Mat))
{
if(identical(Vec,Mat[i,]))
{
return(i)
}
}
print("Error has occured, the vector is not in the matrix ")
return(-1)
}
#Action Cost C_j
CostOfActionOnNode<-function(Node,StateVector,NodeMovedTo,n,CostVec,BVec,LambdaVec)
{
stopifnot(length(StateVector)==2*n)
if(NodeMovedTo!=Node)
{
if(StateVector[Node] >= BVec[Node])
{
return(CostVec[Node]*(LambdaVec[Node]*(StateVector[Node]-BVec[Node])+StateVector[n+Node]))
}
else if(StateVector[Node] < BVec[Node])
{
return(0)
}
}
else if(NodeMovedTo==Node)
{
if(StateVector[NodeMovedTo]-1 >= BVec[Node])
{
return(CostVec[Node]*(LambdaVec[Node]*(StateVector[Node]-1-BVec[Node])+StateVector[n+Node]))
}
else if(StateVector[NodeMovedTo] >= BVec[Node])
{
return(CostVec[Node]*StateVector[n+Node])
}
else if(StateVector[NodeMovedTo] < BVec[Node])
{
return(0)
}
}
print("Error: I have finished without returning anythiny")
}
#Total action cost
CostOfAction<-function(StateVector,NodeMovedTo,n,CostVec,BVec,LambdaVec)
{
Sum=0
for(j in 1:n)
{
Sum=Sum+CostOfActionOnNode(j,StateVector,NodeMovedTo,n,CostVec,BVec,LambdaVec)
}
return(Sum)
}
#create for a state the constraint matrix parts for a particular state
CreateConstraintMatrixForState<-function(StateVector,AdjMatrix,n,BVec,bVec,CostVec,LambdaVec,SVStateSpace=NULL)
{
if(is.null(SVStateSpace))
{
SVStateSpace=CreateSVStates(n,BVec,bVec)
}
#To find out out the list of nodes we can choose to move to we need to look which s_i=1 in our state
CurrentNode=min(StateVector[1:n]) #just look in the S state space
CurrentNodeRow=AdjMatrix[CurrentNode,]
#Now create a vector of nodes we can move to
Actions=vector(length=0)
for(Node in 1:n)
{
if(CurrentNodeRow[Node]==1)
{
Actions=c(Actions,Node)
}
}
#Number of variables is 1 plus all the state spaces
NoOfVariables=1+nrow(SVStateSpace)
#creating the LHS matrix part A
ALHS=matrix(nrow=0,ncol=NoOfVariables)
#storage for the RHS vector part b
bRHS=vector(length=0)
#Create the matrix row by row
for(NodeToMoveTo in Actions)
{
#We will now create the constraint for taking that action
ConstraintRow=vector(length=NoOfVariables)
#new SV state and probability
NewSVStateList=NewSVState(StateVector,NodeToMoveTo,BVec,bVec,LambdaVec)$State
NewSVStateProbList=NewSVState(StateVector,NodeToMoveTo,BVec,bVec,LambdaVec)$Prob
#Now we need the identity of such a state
IDNewSVStateVector=vector(length=nrow(NewSVStateList))
for(i in 1:nrow(NewSVStateList))
{
IDNewSVStateVector[i]=IdenityRow(NewSVStateList[i,],SVStateSpace)+1 #Note we add one as we have the variable g
}
#now we can create the Constraint row
ConstraintRow[1]=1 #as the g is always part of it
ConstraintRow[IdenityRow(StateVector,SVStateSpace)+1]=1 #as we have one lot of h(current state)
for(i in 1:length(IDNewSVStateVector))
{
ConstraintRow[IDNewSVStateVector[i]]=ConstraintRow[IDNewSVStateVector[i]]-NewSVStateProbList[i]
}
ALHS=rbind(ALHS,ConstraintRow)
bRHS=c(bRHS,CostOfAction(StateVector,NodeToMoveTo,n,CostVec,BVec,LambdaVec))
}
return(list(LHS=ALHS,RHS=bRHS))
}
CreateConstraintMatrix<-function(AdjMatrix,n,BVec,bVec,CostVec,LambdaVec)
{
#We now repeat for each possible state the construction and bind together
print("Constructing SV State Space")
SVStateSpace=CreateSVStates(n,BVec,bVec)
print("Constructed")
NoOfVariables=1+nrow(SVStateSpace)
FullConstraintMatrix=matrix(nrow=0,ncol=NoOfVariables)
Fullbounds=vector(length=0)
for(i in 1:nrow(SVStateSpace))
{
print("On state")
print(SVStateSpace[i,])
#For each state run prior construction and retreive
FullConstraintMatrix=rbind(FullConstraintMatrix,CreateConstraintMatrixForState(SVStateSpace[i,],AdjMatrix,n,BVec,bVec,CostVec,LambdaVec,SVStateSpace)$LHS)
Fullbounds=c(Fullbounds,CreateConstraintMatrixForState(SVStateSpace[i,],AdjMatrix,n,BVec,bVec,CostVec,LambdaVec,SVStateSpace)$RHS)
}
return(list(MatrixConstraints=FullConstraintMatrix,VectorBounds=Fullbounds))
}
SolveLP<-function(AdjMatrix,n,BVec,bVec,CostVec,LambdaVec)
{
CreatedAb=CreateConstraintMatrix(AdjMatrix,n,BVec,bVec,CostVec,LambdaVec)
A=CreatedAb$MatrixConstraints
b=CreatedAb$VectorBounds
Objdir="max"
Objective=c(1,rep(0,(ncol(A)-1)))
Constdir=rep("<=",nrow(A))
Solved=lp(Objdir,Objective,A,Constdir,b)
return(list(Value=Solved ,Solution=Solved$solution))
}
IndicesForNodes(2,EqualStepIndexForNode,c(2,3),c(0,0),c(4,3),c(2,1),c(0,0),c(44.4,2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(1,1),c(4,3),c(2,1),c(0,0),c(44.4,2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(2,1),c(4,3),c(2,1),c(0,0),c(44.4,2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(6,1),c(4,3),c(2,1),c(0,0),c(44.4,2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(6,1),c(4,3),c(2,1),c(8,0),c(44.4,2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(6,1),c(4,3),c(2,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(6,1),c(4,3),c(88,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(2,3),c(6,1),c(4,3),c(88,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(6,1),c(4,3),c(88,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(6,1),c(4,3),c(88,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(100,3),c(6,1),c(4,3),c(88,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(100,3),c(6,1),c(4,3),c(88,1),c(8,0),c(44.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(100,3),c(6,1),c(4,3),c(88,1),c(8,0),c(1.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(5,3),c(6,1),c(4,3),c(88,1),c(8,0),c(1.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(2,3),c(6,1),c(4,3),c(88,1),c(8,0),c(1.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(6,1),c(4,3),c(88,1),c(8,0),c(1.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(6,1),c(4,3),c(88,1),c(8,0),c(1.4,20))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(6,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(2,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(4,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(5,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(1,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(2,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(3,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,EqualStepIndexForNode,c(1,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(1,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
source("Optimal solution by LP.R")
FindVMax<-function(Lambda,b,x)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
CurrentMax=-1
for(v in 0:(b+1))
{
if(v <= (Lambda * (1-R)))
{
CurrentMax=v
}
else
{
return(CurrentMax)
}
}
return(CurrentMax)
}
CreateVMaxVector<-function(n,LambdaVec,bVec,xVec)
{
VMaxVec=vector(length=n)
for(i in 1:n)
{
VMaxVec[i]=FindVMax(LambdaVec[i],bVec[i],xVec[i])
}
return(VMaxVec)
}
Delta<-function(tilde=FALSE,CostAtNode,Lambda,b,x,v,vMax)
{
#First calculate B and the remainder
B=ceiling(x)
R=B-x
if(tilde==FALSE)
{
#Calculate Sum
Sum=Lambda * R * (B+1) + v * (B+1-TruncPoissonHazard(Lambda,b,v))
if(v>0)
{
for(i in 0:(v-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return (Sum)
}
if(tilde==TRUE)
{
#Now calculate sum
Sum= Lambda * (B+1 - R * TruncPoissonHazard(Lambda,b,vMax))
if(vMax>0)
{
for(i in 0:(vMax-1))
{
Sum=Sum- i * TruncPoissonPMF(Lambda,b,i)
}
}
Sum=CostAtNode * Sum
return(Sum)
}
}
PlainIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s < B)
{
return(0)
}
else if(s==B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
EqualStepIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s <= B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax)*(s/B))
}
else if(s <= B && v >=vMax)
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax)*(s/B))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
IncreasingStepIndexForNode<-function(s,v,Cost,Lambda,b,x,vMax)
{
#First calculate B
B=ceiling(x)
if(s <= B && v < vMax)
{
return(Delta(tilde = FALSE,Cost,Lambda,b,x,v,vMax)/(B+1-s))
}
else if(s <= B && v >=vMax)
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax)/(B+1-s))
}
else
{
return(Delta(tilde = TRUE,Cost,Lambda,b,x,v,vMax))
}
}
IndicesForNodes<-function(n,IndexForNodeFunction,sVec,vVec,CostVec,LambdaVec,bVec,xVec,vMaxVec=NULL)
{
if(is.null(vMaxVec))
{
#Create vMaxVec
vMaxVec=CreateVMaxVector(n,LambdaVec,bVec,xVec)
}
#Now for each node we find its index
Indices=vector(length=n)
for(i in 1:n)
{
Indices[i]=IndexForNodeFunction(sVec[i],vVec[i],CostVec[i],LambdaVec[i],bVec[i],xVec[i],vMaxVec[i])
}
return(Indices)
}
IndicesForNodes(2,IncreasingStepIndexForNode,c(1,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(2,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(2,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(0,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(1,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(2,3),c(0,1),c(1,1),c(1,1),c(2,3),c(1.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(2,3),c(0,1),c(1,1),c(1,1),c(2,3),c(3.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(1,3),c(0,1),c(1,1),c(1,1),c(2,3),c(3.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(3,3),c(0,1),c(1,1),c(1,1),c(2,3),c(3.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(4,3),c(0,1),c(1,1),c(1,1),c(2,3),c(3.4,2.2))
IndicesForNodes(2,IncreasingStepIndexForNode,c(5,3),c(0,1),c(1,1),c(1,1),c(2,3),c(3.4,2.2))
