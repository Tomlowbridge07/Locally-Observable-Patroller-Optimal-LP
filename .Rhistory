for(i in 1:50)
{
AddUp=AddUp+Multitestmatrix[[i]]
}
AddUp/50
View(Multitestmatrix)
Multitestmatrix[[117]]
Multitestmatrix[[167]]
Multitestmatrix[[217]]
Multitestmatrix[[267]]
Multitestmatrix[[317]]
RunTestForMultipleHeuristics(matrix(c(1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,0,1),nrow=5,byrow = T),c(1.859,1.371,1.96,1.14,1.915),c(2,2,1,2,0),c(0.27,0.599,0.3,0.742,0.589),c(0.0005,0.66,1.53,0.182,0.086),ListOfHeuristics,ListOfDepths,ListOfDepths,300)
RunTestForMultipleHeuristics(matrix(c(1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,0,1),nrow=5,byrow = T),c(1.859,1.371,1.96,1.14,1.915),c(2,2,1,2,0),c(0.27,0.599,0.3,0.742,0.589),c(0.0005,0.66,1.53,0.182,0.086),ListOfHeuristics,ListOfDepths,ListOfIndices,300)
RunTestForMultipleHeuristics(matrix(c(1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,0,1),nrow=5,byrow = T),c(1.859,1.371,1.96,1.24,1.915),c(2,2,1,2,0),c(0.27,0.599,0.3,0.742,0.589),c(0.0005,0.66,1.53,0.182,0.086),ListOfHeuristics,ListOfDepths,ListOfIndices,300)
RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
NegativeErroDebugRunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
NegativeErroDebug=RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
NegativeErroDebug=RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
NegativeErroDebug=RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
NegativeErroDebug=RunTestForMultipleScenarios(1,ListOfHeuristics,ListOfDepths,ListOfIndices,100,3,5,1,2,0,2,0,2,0,2)
View(NegativeErroDebug)
NegativeErroDebug[[2]]
NegativeErroDebug[[3]]
NegativeErroDebug[[4]]
NegativeErroDebug[[5]]
NegativeErroDebug[[6]]
NegativeErroDebug[[7]]
RunTestForMultipleHeuristics(NegativeErroDebug[[2]],NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],ListOfHeuristics,ListOfDepths,ListOfIndices,300)
View(NegativeErroDebug)
RunTestForMultipleHeuristics(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],ListOfHeuristics,ListOfDepths,ListOfIndices,300)
RunTest(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],MultiStepBenefitHeuristic,1,PlainIndexForNode,300)
source("Simulation of Heuristic.R")
#This function runs our optimality and heuristic policy to compare the answers
#It runs the optimal policy to find the optimal answer then runs the policy in value iteration
RunTest<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,HeuristicFunction,HeuristicDepth,IndexForNodeFunction,MaxStepsForIteration,UseValueItForOptimal=FALSE,ValueItOptMaxSteps=500,ValueItOptTolerance=0.001)
{
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(UseValueItForOptimal==FALSE)
{
print("We are going to solve the dual problem first")
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
else if(UseValueItForOptimal==TRUE)
{
#Instead we use value iteration to get the 'optimal' answer
print("We are going to solve value iteration to near optimum")
DualSolved=ValueIterationForGame(ValueItOptMaxSteps,ValueItOptTolerance,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$LowerBound
StateSpace=DualSolved$StateSpace
print(paste("Value iteration solved for:",toString(DualObjectiveValue)))
}
#We now create the Heuristic policy
print("We are creating the Heuristic Policy")
PolicyByHeuristic=HeuristicPolicy(HeuristicDepth,HeuristicFunction,n,AdjacencyMatrix,IndexForNodeFunction,CostVec,LambdaVec,bVec,xVec,StateSpace)
print("Policy Has been created")
#Run the Heurstic policy
#We will select the tolerance to depend on the answer above, because we care about the size of the error we will work to a minimum error of 0.01% so that is we care about a tenthousandth error
ToleranceForIt=10^floor(log10(DualObjectiveValue)-4)
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
#ValueFuncByHeuristic=ValueFunctionForPolicy(100,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
print(AbsError)
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
return(PercentageError)
}
RunTest(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],MultiStepBenefitHeuristic,1,PlainIndexForNode,300)
F=F
FALSE==FALSE
source("Simulation of Heuristic.R")
#This function runs our optimality and heuristic policy to compare the answers
#It runs the optimal policy to find the optimal answer then runs the policy in value iteration
RunTest<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,HeuristicFunction,HeuristicDepth,IndexForNodeFunction,MaxStepsForIteration,UseValueItForOptimal=FALSE,ValueItOptMaxSteps=500,ValueItOptTolerance=0.001)
{
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(UseValueItForOptimal==FALSE)
{
print("We are going to solve the dual problem first")
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
else if(UseValueItForOptimal==TRUE)
{
#Instead we use value iteration to get the 'optimal' answer
print("We are going to solve value iteration to near optimum")
DualSolved=ValueIterationForGame(ValueItOptMaxSteps,ValueItOptTolerance,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$LowerBound
StateSpace=DualSolved$StateSpace
print(paste("Value iteration solved for:",toString(DualObjectiveValue)))
}
#We now create the Heuristic policy
print("We are creating the Heuristic Policy")
PolicyByHeuristic=HeuristicPolicy(HeuristicDepth,HeuristicFunction,n,AdjacencyMatrix,IndexForNodeFunction,CostVec,LambdaVec,bVec,xVec,StateSpace)
print("Policy Has been created")
#Run the Heurstic policy
#We will select the tolerance to depend on the answer above, because we care about the size of the error we will work to a minimum error of 0.01% so that is we care about a tenthousandth error
ToleranceForIt=10^floor(log10(DualObjectiveValue)-4)
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
#ValueFuncByHeuristic=ValueFunctionForPolicy(100,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$LowerBound - DualObjectiveValue
print(AbsError)
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
return(PercentageError)
}
FALSE==FALSE
RunTest(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],MultiStepBenefitHeuristic,1,PlainIndexForNode,300)
source("Simulation of Heuristic.R")
#This function runs our optimality and heuristic policy to compare the answers
#It runs the optimal policy to find the optimal answer then runs the policy in value iteration
RunTest<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,HeuristicFunction,HeuristicDepth,IndexForNodeFunction,MaxStepsForIteration,UseValueItForOptimal=FALSE,ValueItOptMaxSteps=500,ValueItOptTolerance=0.001)
{
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(UseValueItForOptimal==FALSE)
{
print("We are going to solve the dual problem first")
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
else if(UseValueItForOptimal==TRUE)
{
#Instead we use value iteration to get the 'optimal' answer
print("We are going to solve value iteration to near optimum")
DualSolved=ValueIterationForGame(ValueItOptMaxSteps,ValueItOptTolerance,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$LowerBound
StateSpace=DualSolved$StateSpace
print(paste("Value iteration solved for:",toString(DualObjectiveValue)))
}
#We now create the Heuristic policy
print("We are creating the Heuristic Policy")
PolicyByHeuristic=HeuristicPolicy(HeuristicDepth,HeuristicFunction,n,AdjacencyMatrix,IndexForNodeFunction,CostVec,LambdaVec,bVec,xVec,StateSpace)
print("Policy Has been created")
#Run the Heurstic policy
#We will select the tolerance to depend on the answer above, because we care about the size of the error we will work to a minimum error of 0.01% so that is we care about a tenthousandth error
ToleranceForIt=10^floor(log10(DualObjectiveValue)-4)
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
#ValueFuncByHeuristic=ValueFunctionForPolicy(100,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
print(AbsError)
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
return(PercentageError)
}
source("Simulation of Heuristic.R")
#This function runs our optimality and heuristic policy to compare the answers
#It runs the optimal policy to find the optimal answer then runs the policy in value iteration
RunTest<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,HeuristicFunction,HeuristicDepth,IndexForNodeFunction,MaxStepsForIteration,UseValueItForOptimal=FALSE,ValueItOptMaxSteps=500,ValueItOptTolerance=0.001)
{
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(UseValueItForOptimal==FALSE)
{
print("We are going to solve the dual problem first")
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
else if(UseValueItForOptimal==TRUE)
{
#Instead we use value iteration to get the 'optimal' answer
print("We are going to solve value iteration to near optimum")
DualSolved=ValueIterationForGame(ValueItOptMaxSteps,ValueItOptTolerance,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$LowerBound
StateSpace=DualSolved$StateSpace
print(paste("Value iteration solved for:",toString(DualObjectiveValue)))
}
#We now create the Heuristic policy
print("We are creating the Heuristic Policy")
PolicyByHeuristic=HeuristicPolicy(HeuristicDepth,HeuristicFunction,n,AdjacencyMatrix,IndexForNodeFunction,CostVec,LambdaVec,bVec,xVec,StateSpace)
print("Policy Has been created")
#Run the Heurstic policy
#We will select the tolerance to depend on the answer above, because we care about the size of the error we will work to a minimum error of 0.01% so that is we care about a tenthousandth error
ToleranceForIt=10^floor(log10(DualObjectiveValue)-10)
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
#ValueFuncByHeuristic=ValueFunctionForPolicy(100,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
print(AbsError)
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
return(PercentageError)
}
RunTest(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],MultiStepBenefitHeuristic,1,PlainIndexForNode,300)
source("Simulation of Heuristic.R")
#This function runs our optimality and heuristic policy to compare the answers
#It runs the optimal policy to find the optimal answer then runs the policy in value iteration
RunTest<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,HeuristicFunction,HeuristicDepth,IndexForNodeFunction,MaxStepsForIteration,UseValueItForOptimal=FALSE,ValueItOptMaxSteps=500,ValueItOptTolerance=0.001)
{
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(UseValueItForOptimal==FALSE)
{
print("We are going to solve the dual problem first")
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
else if(UseValueItForOptimal==TRUE)
{
#Instead we use value iteration to get the 'optimal' answer
print("We are going to solve value iteration to near optimum")
DualSolved=ValueIterationForGame(ValueItOptMaxSteps,ValueItOptTolerance,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$LowerBound
StateSpace=DualSolved$StateSpace
print(paste("Value iteration solved for:",toString(DualObjectiveValue)))
}
#We now create the Heuristic policy
print("We are creating the Heuristic Policy")
PolicyByHeuristic=HeuristicPolicy(HeuristicDepth,HeuristicFunction,n,AdjacencyMatrix,IndexForNodeFunction,CostVec,LambdaVec,bVec,xVec,StateSpace)
print("Policy Has been created")
#Run the Heurstic policy
#We will select the tolerance to depend on the answer above, because we care about the size of the error we will work to a minimum error of 0.01% so that is we care about a tenthousandth error
ToleranceForIt=10^floor(log10(DualObjectiveValue)-20)
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
#ValueFuncByHeuristic=ValueFunctionForPolicy(100,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
print(AbsError)
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
return(PercentageError)
}
RunTest(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],MultiStepBenefitHeuristic,1,PlainIndexForNode,300)
source("Simulation of Heuristic.R")
#This function runs our optimality and heuristic policy to compare the answers
#It runs the optimal policy to find the optimal answer then runs the policy in value iteration
RunTest<-function(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,HeuristicFunction,HeuristicDepth,IndexForNodeFunction,MaxStepsForIteration,UseValueItForOptimal=FALSE,ValueItOptMaxSteps=500,ValueItOptTolerance=0.001)
{
n=nrow(AdjacencyMatrix)
#We first solve for optimality using the dual
if(UseValueItForOptimal==FALSE)
{
print("We are going to solve the dual problem first")
DualSolved=SolveDualLP(AdjacencyMatrix,n,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$Value
StateSpace=DualSolved$StateSpace
print(paste("Dual has been solved for:",toString(DualObjectiveValue)))
}
else if(UseValueItForOptimal==TRUE)
{
#Instead we use value iteration to get the 'optimal' answer
print("We are going to solve value iteration to near optimum")
DualSolved=ValueIterationForGame(ValueItOptMaxSteps,ValueItOptTolerance,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec)
DualObjectiveValue=DualSolved$LowerBound
StateSpace=DualSolved$StateSpace
print(paste("Value iteration solved for:",toString(DualObjectiveValue)))
}
#We now create the Heuristic policy
print("We are creating the Heuristic Policy")
PolicyByHeuristic=HeuristicPolicy(HeuristicDepth,HeuristicFunction,n,AdjacencyMatrix,IndexForNodeFunction,CostVec,LambdaVec,bVec,xVec,StateSpace)
print("Policy Has been created")
#Run the Heurstic policy
#We will select the tolerance to depend on the answer above, because we care about the size of the error we will work to a minimum error of 0.01% so that is we care about a tenthousandth error
ToleranceForIt=10^floor(log10(DualObjectiveValue)-4)
ValueItByHeuristic=ValueIterationForPolicy(MaxStepsForIteration,ToleranceForIt,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
#ValueFuncByHeuristic=ValueFunctionForPolicy(100,StateSpace,AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,PolicyByHeuristic)
ValueFuncByHeuristic=ValueItByHeuristic$ValueFunction
ValueFunSteps=ValueItByHeuristic$StepsRun
AverageByFunc=mean(ValueFuncByHeuristic)/ValueFunSteps
#We now work out the level of error and return it
AbsError=ValueItByHeuristic$UpperBound - DualObjectiveValue
print(AbsError)
PercentageError=(AbsError/DualObjectiveValue) *100
AltAbsError=AverageByFunc-DualObjectiveValue
AltPercentageError=(AltAbsError/DualObjectiveValue) *100
print(paste("Percentage Error by Iteration is:",toString(PercentageError)))
print(paste("Percentage Error by Function is:",toString(AltPercentageError)))
return(PercentageError)
}
RunTest(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],MultiStepBenefitHeuristic,1,PlainIndexForNode,300)
RunTestForMultipleHeuristics(NegativeErroDebug[[3]],NegativeErroDebug[[4]],NegativeErroDebug[[5]],NegativeErroDebug[[6]],NegativeErroDebug[[7]],ListOfHeuristics,ListOfDepths,ListOfIndices,300)
NegativeErroDebug[[7]]
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=7)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenarios(1,1,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
print("Generated Scenario")
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
print(BestHeuristics)
print(MinError)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
#print(Scenario)
}
return(ScenarioRecording)
}
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=7)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenarios(2,2,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
print("Generated Scenario")
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
print(BestHeuristics)
print(MinError)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
#print(Scenario)
}
return(ScenarioRecording)
}
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=7)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenarios(3,3,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
print("Generated Scenario")
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
print(BestHeuristics)
print(MinError)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
#print(Scenario)
}
return(ScenarioRecording)
}
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=7)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenarios(3,3,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
print("Generated Scenario")
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
print(AdjacencyMatrix)
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
print(BestHeuristics)
print(MinError)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
#print(Scenario)
}
return(ScenarioRecording)
}
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
#Using a B vector and not just a flat value
CreateSStates<-function(n,BVec)
{
#First create for the highest B
BMax=max(BVec)
StateSpace=CreateSStatesForConstantB(n,BMax)
print(BVec)
#Then we have to go through the state space and reduce the columns to the maximum allowed for the node
for(i in 1:nrow(StateSpace))
{
for(j in 1:n)
{
if(StateSpace[i,j] > BVec[j]+1)
{
StateSpace[i,j]=BVec[j]+1
}
}
}
#However now we may have repeated states, so we will go through and remove duplicate rows
StateSpace=unique(StateSpace)
return(StateSpace)
}
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
#This function is going to run the test for multiple scenarios- With a fixed complete graph
RunTestForMultipleScenariosCompleteGraphs<-function(NumberOfScenarios,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration,
SizeOfCompleteGraph,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
{
#This  matrix  stores the minerror,the best heuristic and the scenario
ScenarioRecording=matrix(list(),nrow=NumberOfScenarios,ncol=7)
for(ScenarioNumber in 1:NumberOfScenarios)
{
#For each scenario we generate  the  scenario
Scenario=GenerateTestScenarios(SizeOfCompleteGraph,SizeOfCompleteGraph,MinAttackTime,MaxAttackTime,MinObservedSize,MaxObservedSize,MinArrivalRate,MaxArrivalRate,MinCost,MaxCost)
print("Generated Scenario")
AdjacencyMatrix=matrix(rep(1,SizeOfCompleteGraph*SizeOfCompleteGraph),nrow=SizeOfCompleteGraph)
print(AdjacencyMatrix)
xVec=Scenario$xVec
bVec=Scenario$bVec
LambdaVec=Scenario$LambdaVec
CostVec=Scenario$CostVec
ScenarioTest=RunTestForMultipleHeuristics(AdjacencyMatrix,xVec,bVec,CostVec,LambdaVec,ListOfHeuristicFunctions,ListOfHeuristicDepths,ListOfIndexForNodeFunctions,MaxStepsForIteration)
BestHeuristics=ScenarioTest$BestHeuristics
MinError=ScenarioTest$MinError
print(BestHeuristics)
print(MinError)
ScenarioRecording[[ScenarioNumber,1]]=MinError
ScenarioRecording[[ScenarioNumber,2]]=BestHeuristics
ScenarioRecording[[ScenarioNumber,3]]=AdjacencyMatrix
ScenarioRecording[[ScenarioNumber,4]]=xVec
ScenarioRecording[[ScenarioNumber,5]]=bVec
ScenarioRecording[[ScenarioNumber,6]]=LambdaVec
ScenarioRecording[[ScenarioNumber,7]]=CostVec
#print(Scenario)
}
return(ScenarioRecording)
}
RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
CompleteGraphTest=RunTestForMultipleScenariosCompleteGraphs(1,ListOfHeuristics,ListOfDepths,ListOfIndices,300,4,1,3.5,0,2,0,1,1,1)
